#!/srv/whitlam/bio/apps/12.04/sw/python/2.7.4/bin/python

###############################################################################
#
# checkm - main program entry point. See checkm/checkm.py for internals.
#
###############################################################################
#                                                                             #
#    This program is free software: you can redistribute it and/or modify     #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License, or        #
#    (at your option) any later version.                                      #
#                                                                             #
#    This program is distributed in the hope that it will be useful,          #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#                                                                             #
#    You should have received a copy of the GNU General Public License        #
#    along with this program. If not, see <http://www.gnu.org/licenses/>.     #
#                                                                             #
###############################################################################

__author__ = "Donovan Parks, Connor Skennerton, Michael Imelfort"
__copyright__ = "Copyright 2013"
__credits__ = ["Donovan Parks", "Connor Skennerton", "Michael Imelfort"]
__license__ = "GPL3"
__maintainer__ = "Donovan Parks"
__email__ = "donovan.parks@gmail.com"
__status__ = "Development"
__version__ = "0.0.1"

import argparse
import sys

from checkm import checkm, defaultValues

def printHelp():
    print ''
    print '           ...::: CheckM v' + __version__ + ' :::...'''
    print '''\

  Estimate completeness and contamination of putative genome bins.
    
  Standard workflow:

    checkm analyze     -> Identify marker genes in genome bins
    checkm qa          -> Assess bins for contamination and completeness
    checkm align       -> Create alignments of matched marker genes


  Combined workflow:

    checkm all         -> Build and test in one step
    
    
  Plotting functions:
    
    checkm Nx_plot     -> Create Nx-plot 
    checkm GC_plot     -> Create GC histogram
    checkm Marker_plot -> Plot position of marker genes on sequences
    
    
  Utility functions:

    checkm unbinned    -> Identify unbinned sequences  
    checkm coverage    -> Calculate coverage for all sequences

    USE: checkm OPTION -h to see detailed options
    '''

if __name__ == '__main__':

    # initialize the options parser
    parser = argparse.ArgumentParser(add_help=False)
    subparsers = parser.add_subparsers(help="--", dest='subparser_name')
    taxon_parser = argparse.ArgumentParser(add_help=False)
    taxon_parser.add_argument('-T', '--tax-string', dest='taxonomy', required=False,
        help='specify a Greengenes taxonomy string for the lineage of interest')
    taxon_parser.add_argument('-d', '--database', dest='database',
        help='specify a different path for the marker database. The default is to use the value of the environmental variable "CHECKM_DB"')

    output_parser = argparse.ArgumentParser(add_help=False)
    output_parser.add_argument('-o', '--output-format', dest='out_format',
            type=int,
            help='''change the output format to one of the following:
                1. summary statistics for each genome bin including GC distribution, genome size, completeness estimation, and contamination estimation
                2. brief summary of genome bin completeness and contamination
                3. list of marker names and their counts
                4. matrix of marker counts
                5. list of bin name, marker name, scaffold name
                6. list of markers present multiple times in a bin
                7. list showing scaffold that contain more than one copy of the same marker
                8. list of scaffold name, bin name, length, GC, marker name(s)''', 
            default=1, choices=[1, 2, 3, 4, 5, 6, 7, 8])
    output_parser.add_argument('-f', '--file', default='STDOUT', help="print results to file")

    # identify marker genes within binned contigs and calculate genome statistics
    analyze_parser = subparsers.add_parser('analyze',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='Identify marker genes in bins and calculate genome statistics.',
                                        parents=[taxon_parser],
                                        description='Identify marker genes in bins and calculate genome statistics.')
    analyze_parser.add_argument('out_folder', help="a place to write output files")
    analyze_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    analyze_parser.add_argument('infiles', nargs='*', metavar="FASTA",
                              help="(Optional) a list of fasta formatted files to be used as the input")
    analyze_parser.add_argument('-b', '--bin_folder', help="folder containing bins to check (fasta formatted)")
    analyze_parser.add_argument('-x', '--extension', default='fa',
                             help="used in conjuntion with -b to specify the extension used on files to be parsed")
    analyze_parser.add_argument('-t', '--threads', type=int, default=1, help="max number of active threads")
    analyze_parser.add_argument('-q', '--quiet', action="store_true", default=False, help="suppress console output")

    # do QA on pre-processed contigs
    qa_parser = subparsers.add_parser('qa',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='Assess genome bin for contamination and completeness.',
                                        parents=[output_parser, taxon_parser],
                                        description='Assess genome bin for contamination and completeness.')
    qa_parser.add_argument('out_folder', help="folder specified during build command")
    qa_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    qa_parser.add_argument('-e', '--e_value', type=float, default=defaultValues.__CHECKM_DEFAULT_E_VAL__, help="E-value cut off")
    qa_parser.add_argument('-l', '--length', type=float, default=defaultValues.__CHECKM_DEFAULT_LENGTH__, help="percent overlap between target and query")
    qa_parser.add_argument('-q', '--quiet', action="store_true", default=False, help="suppress console output")

    # produce alignments of matches
    align_parser = subparsers.add_parser('align',
                                         formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                         help='Create alignments of matched marker genes.',
                                         parents=[taxon_parser],
                                         description='Create alignments of matched marker genes.')
    align_parser.add_argument('out_folder', help="folder specified during build command")
    align_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    align_parser.add_argument('-e', '--e_value', type=float, default=defaultValues.__CHECKM_DEFAULT_E_VAL__, help="E-value cut off")
    align_parser.add_argument('-l', '--length', type=float, default=defaultValues.__CHECKM_DEFAULT_LENGTH__, help="percent overlap between target and query")
    align_parser.add_argument('-q', '--quiet', action="store_true", default=False, help="suppress console output")
    align_parser.add_argument('-s', '--separate-files',action="store_true",
            dest="separate", default=False, help="output a separate file for each of the hits to a HMM model.")
    align_parser.add_argument('-o', '--output-format',default='PSIBLAST', dest="out_format", help="the output format passed to hmmalign")
    align_parser.add_argument('-c','--include-consensus',action="store_true", default=False, dest="consensus", help="include the HMM \
            consensus sequence (generated by hmmemit) in the alignment")
    align_parser.add_argument('-b', '--best-hit', action="store_true", default=False, dest="best_alignment", help="only align the best \
            match to the HMM even if there are multiple matches that pass the threshold")

    # Build + align in one step
    pipeline_parser = subparsers.add_parser('all',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='Run find + qa + align in one step.',
                                        parents=[taxon_parser, output_parser],
                                        description='Run find + qa + align in one step.')
    pipeline_parser.add_argument('out_folder', help="a place to write output files")
    pipeline_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    pipeline_parser.add_argument('infiles', nargs='*', metavar="FASTA",
                                 help="(Optional) a list of fasta formatted files to be used as the input")
    pipeline_parser.add_argument('-b', '--bin_folder', help="folder containing bins to check (fasta formatted)")
    pipeline_parser.add_argument('-x', '--extension', default='fa',
                                 help="used in conjuntion with -b to specify the extension used on files to be parsed")
    pipeline_parser.add_argument('-t', '--threads', type=int, default=1, help="max number of active threads")
    pipeline_parser.add_argument('-e', '--e_value', type=float, default=defaultValues.__CHECKM_DEFAULT_E_VAL__, help="E-value cut off")
    pipeline_parser.add_argument('-l', '--length', type=float, default=defaultValues.__CHECKM_DEFAULT_LENGTH__, help="percent overlap between target and query")
    pipeline_parser.add_argument('-q', '--quiet', action="store_true", default=False, help="suppress console output")

    # debug and development
    if False:
        debug_parser = subparsers.add_parser('debug',
                                            formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                            help='rogue mode for use in testing new features',
                                            description='Rogue mode for use in testing new features')
        debug_parser.add_argument('data', help="some data")

    # get and check options
    args = None
    if(len(sys.argv) == 1 or sys.argv[1] == '-h' or sys.argv == '--help'):
        printHelp()
        sys.exit(0)
    else:
        args = parser.parse_args()

    # do what we came here to do
    try:
        checkmParser = checkm.OptionsParser()
        if(False):
            #import pstats
            #p = pstats.Stats('prof')
            #p.sort_stats('cumulative').print_stats(10)
            #p.sort_stats('time').print_stats(10)
            import cProfile
            cProfile.run('checkmParser.parseOptions(args)', 'prof')
        elif False:
            import pdb
            pdb.run(checkmParser.parseOptions(args))
        else:
            checkmParser.parseOptions(args)
    except:
        print "Unexpected error:", sys.exc_info()[0]
        raise


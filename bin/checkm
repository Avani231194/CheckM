#!/srv/whitlam/bio/apps/12.04/sw/python/2.7.4/bin/python

###############################################################################
#
# checkm - main program entry point. See checkm/checkm.py for internals.
#
###############################################################################
#                                                                             #
#    This program is free software: you can redistribute it and/or modify     #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License, or        #
#    (at your option) any later version.                                      #
#                                                                             #
#    This program is distributed in the hope that it will be useful,          #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#                                                                             #
#    You should have received a copy of the GNU General Public License        #
#    along with this program. If not, see <http://www.gnu.org/licenses/>.     #
#                                                                             #
###############################################################################

__author__ = "Donovan Parks, Connor Skennerton, Michael Imelfort"
__copyright__ = "Copyright 2013"
__credits__ = ["Donovan Parks", "Connor Skennerton", "Michael Imelfort"]
__license__ = "GPL3"
__maintainer__ = "Donovan Parks"
__email__ = "donovan.parks@gmail.com"
__status__ = "Development"
__version__ = "0.0.1"

import argparse
import sys

from checkm import checkm, defaultValues

def printHelp():
    print '''\

             ...::: CheckM :::...

    Estimate completeness and contamination of putative genomes.

    checkm build   -> Create the underlying data needed for testing
    checkm qa      -> Test for bin contamination and completeness
    checkm align   -> Create alignments of hmms to the matched markers

    checkm all     -> Build and test in one step

    USE: checkm OPTION -h to see detailed options
    '''

if __name__ == '__main__':

    # intialise the options parser
    parser = argparse.ArgumentParser(add_help=False)
    subparsers = parser.add_subparsers(help="--", dest='subparser_name')
    taxon_parser = argparse.ArgumentParser(add_help=False)
    taxon_parser.add_argument('-T', '--tax-string', dest='taxonomy', required=False,
        help='Specify a Greengenes taxonomy string for the lineage of interest')
    taxon_parser.add_argument('-A', '--all-markers', dest='all_markers', required=False,
        default=False, action='store_true',
        help='Specify a Greengenes taxonomy string for the lineage of interest')
    taxon_parser.add_argument('-d', '--database', dest='database',
        help='Specify a different path for the marker database. The default '\
        'is to use the value of the environmental variable "CHECKM_DB"')

    output_parser = argparse.ArgumentParser(add_help=False)
    output_parser.add_argument('-o', '--output-format', dest='out_format',
            type=int,
            help='''Change the output format to one of the following:
                 1. Simple Summary showing bin name, counts, completeness and
                    contamination
                 2. List of marker names and their counts
                 3. Matrix of marker counts
                 4. Tabular list of bin name, marker name, contig name
                 5. Tabular list showing contigs that contain more than one
                     copy of the same marker. Format: bin name, contig name,
                     {Marker name, count}...''', default=1)

    ##################################################
    # Typical workflow
    ##################################################

    # parse binned contigs
    build_parser = subparsers.add_parser('build',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='parse binned contigs',
                                        parents=[taxon_parser],
                                        description='Parse binned contigs')
    build_parser.add_argument('out_folder', help="a place to write output files")
    build_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    build_parser.add_argument('infiles', nargs='*', metavar="FASTA",
                              help="A list of fasta formatted files to be used as the input")
    build_parser.add_argument('-b', '--bin_folder', help="folder containing bins to check (fasta formatted)")
    build_parser.add_argument('-x', '--extension', default='fa',
                             help="used in conjuntion with -b to specify the extension used on files to be parsed")
    build_parser.add_argument('-t', '--threads', type=int, default=1, help="max number of active threads")
    build_parser.add_argument('-p', '--prefix', default='', help="prefix used for naming output files")
    build_parser.add_argument('-v', '--verbose', action="store_true", default=False, help="print more")

    # do QA on pre-processed contigs
    qa_parser = subparsers.add_parser('qa',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='do QA on pre-processed contigs',
                                        parents=[output_parser, taxon_parser],
                                        description='Do QA on pre-processed contigs')
    qa_parser.add_argument('out_folder', help="folder specified during build command")
    qa_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    qa_parser.add_argument('-p', '--prefix', default='', help="prefix which was used for naming output files")
    qa_parser.add_argument('-e', '--e_value', type=float, default=defaultValues.__CHECKM_DEFAULT_E_VAL__, help="e value cut off")
    qa_parser.add_argument('-l', '--length', type=float, default=defaultValues.__CHECKM_DEFAULT_LENGTH__, help="percent overlap between target and query")
    qa_parser.add_argument('-f', '--file', default='STDOUT', help="print results to file")
    qa_parser.add_argument('-v', '--verbose', action="store_true", default=False, help="print more")

    # produce alignments of matches
    align_parser = subparsers.add_parser('align',
                                         formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                         help='create alignments of hmms to the matched markers',
                                         parents=[taxon_parser],
                                         description='Create alignments of hmms to the matched markers')
    align_parser.add_argument('out_folder', help="folder specified during build command")
    align_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    align_parser.add_argument('-p', '--prefix', default='', help="prefix which was used for naming output files")
    align_parser.add_argument('-e', '--e_value', type=float, default=defaultValues.__CHECKM_DEFAULT_E_VAL__, help="e value cut off")
    align_parser.add_argument('-l', '--length', type=float, default=defaultValues.__CHECKM_DEFAULT_LENGTH__, help="percent overlap between target and query")
    align_parser.add_argument('-v', '--verbose', action="store_true", default=False, help="print more")
    align_parser.add_argument('-s', '--separate-files',action="store_true",
            dest="separate", default=False, help="Output a separate file for \
            each of the hits to a HMM model.")
    align_parser.add_argument('-o', '--output-format',default='PSIBLAST',
            dest="out_format", help="The output format passed to hmmalign")
    align_parser.add_argument('-c','--include-consensus',action="store_true",
            default=False, dest="consensus", help="Include the HMM \
            consensus sequence (generated by hmmemit) in the alignment")
    align_parser.add_argument('-b', '--best-hit', action="store_true",
            default=False, dest="best_alignment", help="Only align the best \
            match to the HMM even if there are multiple matches that pass the \
            threshold")

    # Build + align in one step
    pipeline_parser = subparsers.add_parser('all',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='build + qa + align in one step',
                                        parents=[taxon_parser, output_parser],
                                        description='Build + qa in one step')
    pipeline_parser.add_argument('out_folder', help="a place to write output files")
    pipeline_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    pipeline_parser.add_argument('infiles', nargs='*', metavar="FASTA",
                                 help="A list of fasta formatted files to be used as the input")
    pipeline_parser.add_argument('-b', '--bin_folder', help="folder containing bins to check (fasta formatted)")
    pipeline_parser.add_argument('-x', '--extension', default='fa',
                                 help="used in conjuntion with -b to specify the extension used on files to be parsed")
    pipeline_parser.add_argument('-t', '--threads', type=int, default=1, help="max number of active threads")
    pipeline_parser.add_argument('-p', '--prefix', default='', help="prefix used for naming output files")
    pipeline_parser.add_argument('-e', '--e_value', type=float, default=defaultValues.__CHECKM_DEFAULT_E_VAL__, help="e value cut off")
    pipeline_parser.add_argument('-l', '--length', type=float, default=defaultValues.__CHECKM_DEFAULT_LENGTH__, help="percent overlap between target and query")
    pipeline_parser.add_argument('-f', '--file', default='STDOUT', help="print results to file")
    pipeline_parser.add_argument('-v', '--verbose', action="store_true", default=False, help="print more")

    # debug and development
    if False:
        debug_parser = subparsers.add_parser('debug',
                                            formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                            help='rogue mode for use in testing new features',
                                            description='Rogue mode for use in testing new features')
        debug_parser.add_argument('data', help="some data")

    # get and check options
    args = None
    if(len(sys.argv) == 1 or sys.argv[1] == '-h' or sys.argv == '--help'):
        printHelp()
        sys.exit(0)
    else:
        args = parser.parse_args()

    # do what we came here to do
    try:
        checkmParser = checkm.optionsParser()
        if(False):
            #import pstats
            #p = pstats.Stats('prof')
            #p.sort_stats('cumulative').print_stats(10)
            #p.sort_stats('time').print_stats(10)
            import cProfile
            cProfile.run('checkmParser.parseOptions(args)', 'prof')
        elif False:
            import pdb
            pdb.run(checkmParser.parseOptions(args))
        else:
            checkmParser.parseOptions(args)
    except:
        print "Unexpected error:", sys.exc_info()[0]
        raise

###############################################################################
###############################################################################
###############################################################################
###############################################################################


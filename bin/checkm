#!/srv/whitlam/bio/apps/12.04/sw/python/2.7.4/bin/python

###############################################################################
#
# checkm - main program entry point. See checkm/checkm.py for internals.
#
###############################################################################
#                                                                             #
#    This program is free software: you can redistribute it and/or modify     #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License, or        #
#    (at your option) any later version.                                      #
#                                                                             #
#    This program is distributed in the hope that it will be useful,          #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#                                                                             #
#    You should have received a copy of the GNU General Public License        #
#    along with this program. If not, see <http://www.gnu.org/licenses/>.     #
#                                                                             #
###############################################################################

__author__ = "Donovan Parks, Connor Skennerton, Michael Imelfort"
__copyright__ = "Copyright 2013"
__credits__ = ["Donovan Parks", "Connor Skennerton", "Michael Imelfort"]
__license__ = "GPL3"
__maintainer__ = "Donovan Parks"
__email__ = "donovan.parks@gmail.com"
__status__ = "Development"
__version__ = "0.0.1"

import argparse
import sys

from checkm import checkm, defaultValues

def printHelp():
    print ''
    print '           ...::: CheckM v' + __version__ + ' :::...'''
    print '''\

  Estimate completeness and contamination of putative genome bins.
    
  Standard workflow:

    checkm analyze     -> Identify marker genes in genome bins
    checkm qa          -> Assess bins for contamination and completeness
    checkm align       -> Create alignments of matched marker genes


  Combined workflow:

    checkm all         -> Build and test in one step
    
    
  Plotting functions:
    
    checkm nx_plot     -> Create Nx-plots
    checkm len_plot    -> Cumulative sequence length plot
    checkm gc_plot     -> Create GC histogram and delta-GC plot
    checkm marker_plot -> Plot position of marker genes on sequences
    
    
  Utility functions:

    checkm unbinned    -> Identify unbinned sequences  
    checkm coverage    -> Calculate coverage of sequences
    checkm profile     -> Calculate percentage of reads mapped to each bin

    USE: checkm OPTION -h to see detailed options
    '''

if __name__ == '__main__':

    # initialize the options parser
    parser = argparse.ArgumentParser(add_help=False)
    subparsers = parser.add_subparsers(help="--", dest='subparser_name')
    taxon_parser = argparse.ArgumentParser(add_help=False)
    taxon_parser.add_argument('-T', '--tax-string', dest='taxonomy', required=False,
        help='specify a Greengenes taxonomy string for the lineage of interest')
    taxon_parser.add_argument('-d', '--database', dest='database',
        help='specify path to marker database (default is the environmental variable "CHECKM_DB")')

    output_parser = argparse.ArgumentParser(add_help=False)
    output_parser.add_argument('-o', '--output-format', dest='out_format',
            type=int,
            help='''change the output format to one of the following:
                1. summary statistics for each genome bin including GC distribution, genome size, completeness estimation, and contamination estimation
                2. brief summary of genome bin completeness and contamination
                3. list of marker names and their counts
                4. matrix of marker counts
                5. list of bin name, marker name, scaffold name
                6. list of markers present multiple times in a bin
                7. list showing scaffold that contain more than one copy of the same marker
                8. list of scaffold name, bin name, length, GC, marker name(s)''', 
            default=1, choices=[1, 2, 3, 4, 5, 6, 7, 8])
    output_parser.add_argument('-f', '--file', default='STDOUT', help="print results to file")

    # identify marker genes within binned contigs and calculate genome statistics
    analyze_parser = subparsers.add_parser('analyze',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='Identify marker genes in bins and calculate genome statistics.',
                                        parents=[taxon_parser],
                                        description='''Identify marker genes in bins and calculate genome statistics. 
                                                        The set of marker genes to use is specified with either -T or -H.''')
    analyze_parser.add_argument('bin_folder', help="folder containing bins to plot (fasta format)")
    analyze_parser.add_argument('out_folder', help="folder to write output files")
    analyze_parser.add_argument('infiles', nargs='*', metavar="FASTA", help="(Optional) a list of fasta formatted files to be used as the input")
    analyze_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    analyze_parser.add_argument('-x', '--extension', default='fa', help="extension of bins (all other files in bin folder are ignored)")
    analyze_parser.add_argument('-t', '--threads', type=int, default=1, help="max number of active threads")
    analyze_parser.add_argument('-q', '--quiet', dest='bQuiet', action="store_true", default=False, help="suppress console output")

    # do QA on pre-processed contigs
    qa_parser = subparsers.add_parser('qa',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='Assess genome bin for contamination and completeness.',
                                        parents=[output_parser, taxon_parser],
                                        description='''Assess genome bin for contamination and completeness. 
                                                        The set of marker genes used must be specified with -T or -H.''')
    qa_parser.add_argument('out_folder', help="folder specified during analyze command")
    qa_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    qa_parser.add_argument('-e', '--e_value', type=float, default=defaultValues.__CHECKM_DEFAULT_E_VAL__, help="E-value cut off")
    qa_parser.add_argument('-l', '--length', type=float, default=defaultValues.__CHECKM_DEFAULT_LENGTH__, help="percent overlap between target and query")
    qa_parser.add_argument('-q', '--quiet', dest='bQuiet', action="store_true", default=False, help="suppress console output")

    # produce alignments of matches
    align_parser = subparsers.add_parser('align',
                                         formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                         help='Create alignments of matched marker genes.',
                                         parents=[taxon_parser],
                                         description='Create alignments of matched marker genes.')
    align_parser.add_argument('out_folder', help="folder specified during analyze command")
    align_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    align_parser.add_argument('-e', '--e_value', type=float, default=defaultValues.__CHECKM_DEFAULT_E_VAL__, help="E-value cut off")
    align_parser.add_argument('-l', '--length', type=float, default=defaultValues.__CHECKM_DEFAULT_LENGTH__, help="percent overlap between target and query")
    align_parser.add_argument('-q', '--quiet', dest='bQuiet', action="store_true", default=False, help="suppress console output")
    align_parser.add_argument('-s', '--separate-files',action="store_true",
            dest="separate", default=False, help="output a separate file for each of the hits to a HMM model.")
    align_parser.add_argument('-o', '--output-format',default='PSIBLAST', dest="out_format", help="the output format passed to hmmalign")
    align_parser.add_argument('-c','--include-consensus',action="store_true", default=False, dest="consensus", help="include the HMM \
            consensus sequence (generated by hmmemit) in the alignment")
    align_parser.add_argument('-b', '--best-hit', action="store_true", default=False, dest="best_alignment", help="only align the best \
            match to the HMM even if there are multiple matches that pass the threshold")

    # Standard workflow in one step
    pipeline_parser = subparsers.add_parser('all',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='Run analyze + qa + align in one step.',
                                        parents=[taxon_parser, output_parser],
                                        description='''Run analyze + qa + align in one step. 
                                                        The set of marker genes to use is specified with either -T or -H.''')
    pipeline_parser.add_argument('bin_folder', help="folder containing bins to plot (fasta format)")
    pipeline_parser.add_argument('out_folder', help="folder to write output files")
    pipeline_parser.add_argument('-H', '--hmm', dest='hmm', help="hmm used in the search")
    pipeline_parser.add_argument('-x', '--extension', default='fa', help="extension of bins (all other files in bin folder are ignored)")
    pipeline_parser.add_argument('-t', '--threads', type=int, default=1, help="max number of active threads")
    pipeline_parser.add_argument('-e', '--e_value', type=float, default=defaultValues.__CHECKM_DEFAULT_E_VAL__, help="E-value cut off")
    pipeline_parser.add_argument('-l', '--length', type=float, default=defaultValues.__CHECKM_DEFAULT_LENGTH__, help="percent overlap between target and query")
    pipeline_parser.add_argument('-q', '--quiet', dest='bQuiet', action="store_true", default=False, help="suppress console output")
    
    # generic arguments for plots
    plot_parser = argparse.ArgumentParser(add_help=False)
    plot_parser.add_argument('bin_folder', help="folder containing bins to plot (fasta format)")
    plot_parser.add_argument('plot_folder', help="folder to hold plots")
    plot_parser.add_argument('--fig_padding', type = float, default = 0.2, help='white space to place around figure (in inches)')
    plot_parser.add_argument('--image_type', default = 'png', choices=['eps', 'pdf', 'png', 'ps', 'svg'], help='desired image type')
    plot_parser.add_argument('--dpi', type = int, default = 600, help='desired DPI of output image')
    plot_parser.add_argument('--font_size', type = int, default = 8, help='Desired font size')
    plot_parser.add_argument('-x', '--extension', default='fa', help="extension of bins (all other files in bin folder are ignored)")
    
    plot_single_parser = argparse.ArgumentParser('plot_single',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        parents=[plot_parser], add_help=False)
    plot_single_parser.add_argument('--width', type = float, default = 6.5, help='width of output image')
    plot_single_parser.add_argument('--height', type = float, default = 6.5, help='height of output image')
    
    plot_double_parser = argparse.ArgumentParser('plot_double',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        parents=[plot_parser], add_help=False)
    plot_double_parser.add_argument('--width', type = float, default = 6.5, help='width of output image')
    plot_double_parser.add_argument('--height', type = float, default = 3.5, help='height of output image')
    
    # GC histogram
    plot_gc_parser = subparsers.add_parser('gc_plot',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help= 'Create GC histogram and delta-GC plot.',
                                        parents=[plot_double_parser],
                                        description= 'Create GC histogram and delta-GC plot.')
    
    plot_gc_parser.add_argument('-w', '--window_size', help="non-overlapping window size used to calculate GC", type=int, default=1000)
    plot_gc_parser.add_argument('-g', '--gc_bin_width', help="width of GC bars in histogram", type=float, default=0.01) 
    plot_gc_parser.add_argument('-q', '--quiet', dest='bQuiet', action="store_true", default=False, help="suppress console output")
    
    # Nx-plot
    plot_nx_parser = subparsers.add_parser('nx_plot',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='Create Nx-plots.',
                                        parents=[plot_single_parser],
                                        description='Create Nx-plots.')
    
    plot_nx_parser.add_argument('-s', '--step_size', help="x step size for calculating Nx", type=float, default=0.05)
    plot_nx_parser.add_argument('-q', '--quiet', dest='bQuiet', action="store_true", default=False, help="suppress console output")
    
    # Cumulative sequence length plot
    plot_len_parser = subparsers.add_parser('len_plot',
                                        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                        help='Cumulative sequence length plot.',
                                        parents=[plot_single_parser],
                                        description='Cumulative sequence length plot.')

    plot_len_parser.add_argument('-q', '--quiet', dest='bQuiet', action="store_true", default=False, help="suppress console output")
    
    # Calculate coverage
    coverage_parser = subparsers.add_parser('coverage',
                                            formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                            help='Calculate coverage of sequences.',
                                            description='Calculate coverage of sequences.')
    coverage_parser.add_argument('out_file', help="print results to file")
    coverage_parser.add_argument('bam_files', nargs='+', help="BAM files to parse")
    coverage_parser.add_argument('-p', '--pairs_only', action='store_true', default=False, help="ignore reads that are not properly paired")
    coverage_parser.add_argument('-t', '--threads', type=int, default=1, help="max number of active threads")
    coverage_parser.add_argument('-q', '--quiet', dest='bQuiet', action="store_true", default=False, help="suppress console output")

    # debug and development
    if False:
        debug_parser = subparsers.add_parser('debug',
                                            formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                            help='rogue mode for use in testing new features',
                                            description='Rogue mode for use in testing new features')
        debug_parser.add_argument('data', help="some data")

    # get and check options
    args = None
    if(len(sys.argv) == 1 or sys.argv[1] == '-h' or sys.argv == '--help'):
        printHelp()
        sys.exit(0)
    else:
        args = parser.parse_args()

    # do what we came here to do
    try:
        checkmParser = checkm.OptionsParser()
        if(False):
            #import pstats
            #p = pstats.Stats('prof')
            #p.sort_stats('cumulative').print_stats(10)
            #p.sort_stats('time').print_stats(10)
            import cProfile
            cProfile.run('checkmParser.parseOptions(args)', 'prof')
        elif False:
            import pdb
            pdb.run(checkmParser.parseOptions(args))
        else:
            checkmParser.parseOptions(args)
    except:
        print "Unexpected error:", sys.exc_info()[0]
        raise

